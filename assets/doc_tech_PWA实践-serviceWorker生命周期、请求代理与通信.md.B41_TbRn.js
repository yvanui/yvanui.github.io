import{_ as s,c as n,o as a,a6 as e}from"./chunks/framework.d-Ywx6yJ.js";const m=JSON.parse('{"title":"[PWA实践]serviceWorker生命周期、请求代理与通信","description":"","frontmatter":{"title":"[PWA实践]serviceWorker生命周期、请求代理与通信","date":"2018-02-11T15:05:43.000Z"},"headers":[],"relativePath":"doc/tech/PWA实践-serviceWorker生命周期、请求代理与通信.md","filePath":"doc/tech/PWA实践-serviceWorker生命周期、请求代理与通信.md"}'),p={name:"doc/tech/PWA实践-serviceWorker生命周期、请求代理与通信.md"},r=e(`<p>本文主要讲 serviceWorker 生命周期和挂载、卸载等问题，适合对 serviceWorker 的作用有所了解但是具体细节不是特别清楚的读者</p><p><strong>以下所有分析基于 Chrome V63</strong></p><h3 id="serviceworker的挂载" tabindex="-1">serviceWorker的挂载 <a class="header-anchor" href="#serviceworker的挂载" aria-label="Permalink to &quot;serviceWorker的挂载&quot;">​</a></h3><p>先来一段代码感受serviceWorker注册:</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>if (&#39;serviceWorker&#39; in navigator) {</span></span>
<span class="line"><span>      window.addEventListener(&#39;load&#39;, function () {</span></span>
<span class="line"><span>          navigator.serviceWorker.register(&#39;/sw.js&#39;, {scope: &#39;/&#39;})</span></span>
<span class="line"><span>              .then(function (registration) {</span></span>
<span class="line"><span>                  // 注册成功</span></span>
<span class="line"><span>                  console.log(&#39;ServiceWorker registration successful with scope: &#39;, registration.scope);</span></span>
<span class="line"><span>              })</span></span>
<span class="line"><span>              .catch(function (err) {</span></span>
<span class="line"><span>                  // 注册失败:(</span></span>
<span class="line"><span>                  console.log(&#39;ServiceWorker registration failed: &#39;, err);</span></span>
<span class="line"><span>              });</span></span>
<span class="line"><span>      });</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>通过上述代码，我们定义在<code>/sw.js</code>里的内容就会生效(对于当前页面之前没有 serviceWorker 的情况而言，我们注册的 serviceWorker 肯定会生效，如果当前页面已经有了我们之前注册的 serviceWorker，这个时候涉及到 serviceWorker的更新机制，下文详述)</p><p>如果我们在<code>sw.js</code>没有变化的情况下刷新这个页面，每次还是会有注册成功的回调以及相应的log输出，但是这个时候浏览器发现我们的 serviceWorker 并没有发生变化，并不会重置一遍 serviceWorker</p><h3 id="serviceworker更新" tabindex="-1">serviceWorker更新 <a class="header-anchor" href="#serviceworker更新" aria-label="Permalink to &quot;serviceWorker更新&quot;">​</a></h3><p>我们如果想更新一个 serviceWorker，根据我们的一般web开发策略，可能会想到以下几种策略：</p><ul><li>仅变更文件名(比如把<code>sw.js</code>变成<code>sw-v2.js</code>或者加一个hash)</li><li>仅变更文件内容(仅仅更新<code>sw.js</code>的内容，文件名不变)</li><li>同时变更：同时执行以上两条</li></ul><p>在这里，我可以很负责的告诉你，<strong>变更serviceWorker文件名绝对不是一个好的实践</strong>，浏览器判断 serviceWorker 是否相同基本和文件名没有关系，甚至有可能还会造成浏览器抛出404异常(因为找不到原来的文件名对应的文件了)。</p><p>所以我们只需要变更内容即可，实际上，我们每次打开或者刷新该页面，浏览器都会重新请求一遍 serviceWorker 的定义文件，如果发现文件内容和之前的不同了，这个时候:</p><p>(<em>下文中，我们使用“有关 tab”来表示受 serviceWorker 控制的页面</em>，刷新均指普通刷新(F5/CommandR)并不指Hard Reload)</p><ul><li><p>这个新的 serviceWorker 就会进入到一个 “waiting to activate” 的状态，并且只要我们不关闭这个网站的所有tab(更准确地说，是这个 serviceWorker 控制的所有页面)，新的 serviceWorker 始终不会进入替换原有的进入到 running 状态(就算我们只打开了一个有关 tab，直接刷新也不会让新的替换旧的)。</p></li><li><p>如果我们多次更新了 serviceWorker 并且没有关闭当前的 tab 页面，那么新的 serviceWorker 就会挤掉原先处于第二顺位(waiting to activate)的serviceWorker，变成<code>waiting to activate</code>状态</p></li></ul><p>也就是说，我们只有关闭当前旧的 serviceWorker 控制的所有页面 的所有tab，之后浏览器才会把旧的 serviveWorker 移除掉，换成新的，再打开相应的页面就会使用新的了。</p><p>当然，也有一个特殊情况：如果我们在新的 serviceWorker 使用了<code>self.skipWaiting();</code>，像这样：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>self.addEventListener(&#39;install&#39;, function(event) {</span></span>
<span class="line"><span>    self.skipWaiting();</span></span>
<span class="line"><span>});</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这个时候，要分为以下两种情况：</p><ul><li>如果当前我们只打开了一个有关 tab，这个时候，我们直接刷新，发现新的已经替换掉旧的了。</li><li>如果我们当前打开了若干有关 tab，这个时候，无论我们刷新多少次，新的也不会替换掉旧的，只有我们一个一个关掉tab(或者跳转走)只剩下最后一个了，这个时候刷新，会让新的替换旧的(也就是上一种情况)</li></ul><p>Chrome 的这种机制，防止了同一个页面先后被新旧两个不同的 serviceWorker 接管的情况出现。</p><h4 id="手动更新" tabindex="-1">手动更新 <a class="header-anchor" href="#手动更新" aria-label="Permalink to &quot;手动更新&quot;">​</a></h4><p>虽然说，在页面每次进入的时候浏览器都会检查一遍 serviceWorker 是否更新，但如果我们想要手动更新 serviceWorker 也没有问题：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>navigator.serviceWorker.register(&quot;/sw.js&quot;).then(reg =&gt; {</span></span>
<span class="line"><span>  reg.update();</span></span>
<span class="line"><span>  // 或者 一段时间之后更新</span></span>
<span class="line"><span>});</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>这个时候如果 serviceWorker 变化了，那么会重新触发 install 执行一遍 install 的回调函数，如果没有变，就不会触发这个生命周期。</p><h4 id="install-生命周期钩子" tabindex="-1">install 生命周期钩子 <a class="header-anchor" href="#install-生命周期钩子" aria-label="Permalink to &quot;install 生命周期钩子&quot;">​</a></h4><p>我们一般会在 sw.js 中，添加<code>install</code>的回调，一般在回调中，我们会进行缓存处理操作，像这样：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>self.addEventListener(&#39;install&#39;, function(event) {</span></span>
<span class="line"><span>    console.log(&#39;[sw2] serviceWorker Installed successfully&#39;, event)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    event.waitUntil(</span></span>
<span class="line"><span>        caches.open(&#39;mysite-static-v1&#39;).then(function(cache) {</span></span>
<span class="line"><span>            return cache.addAll([</span></span>
<span class="line"><span>                &#39;/stylesheets/style.css&#39;,</span></span>
<span class="line"><span>                &#39;/javascripts/common.39c462651d449a73b5bb.js&#39;,</span></span>
<span class="line"><span>            ]);</span></span>
<span class="line"><span>        })</span></span>
<span class="line"><span>    )</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>如果我们新打开一个页面，如果之前有 serviceWorker，那么会触发<code>install</code>，如果之前没有， 那么在 serviceWorker 装载后会触发 <code>install</code>。</p><p>如果我们刷新页面，serviceWorker 和之前没有变化或者 serviceWorker 已经处在 <code>waiting to activate</code>，不会触发<code>install</code>，如果有变化，会触发<code>install</code>，但不会接管页面(上文中提到)。</p><h4 id="activate-生命周期钩子" tabindex="-1">activate 生命周期钩子 <a class="header-anchor" href="#activate-生命周期钩子" aria-label="Permalink to &quot;activate 生命周期钩子&quot;">​</a></h4><p>activate 在什么时候被触发呢？</p><p>如果当前页面没有 serviceworker ，那么会在 install 之后触发。</p><p>如果当前页面有 serviceWorker，并且有 serviceWorker更新，新的 serviceWorker 只会触发 install ，不会触发 activate</p><p>换句话说，当前变成 active 的 serviceWorker 才会被触发这个生命周期钩子</p><h3 id="serviceworker-代理请求" tabindex="-1">serviceWorker 代理请求 <a class="header-anchor" href="#serviceworker-代理请求" aria-label="Permalink to &quot;serviceWorker 代理请求&quot;">​</a></h3><p>serviceWorker 代理请求相对来说比较好理解，以下是一个很简单的例子：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>self.addEventListener(&#39;install&#39;, function(event) {</span></span>
<span class="line"><span>    console.log(&#39;[sw2] serviceWorker Installed successfully&#39;, event)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    event.waitUntil(</span></span>
<span class="line"><span>        caches.open(&#39;mysite-static-v1&#39;).then(function(cache) {</span></span>
<span class="line"><span>            return cache.addAll([</span></span>
<span class="line"><span>                &#39;/stylesheets/style.css&#39;,</span></span>
<span class="line"><span>                &#39;/javascripts/common.39c462651d449a73b5bb.js&#39;,</span></span>
<span class="line"><span>            ]);</span></span>
<span class="line"><span>        })</span></span>
<span class="line"><span>    );</span></span>
<span class="line"><span>});</span></span>
<span class="line"><span></span></span>
<span class="line"><span>self.addEventListener(&#39;fetch&#39;, function(event) {</span></span>
<span class="line"><span>    console.log(&#39;Handling fetch event for&#39;, event.request.url);</span></span>
<span class="line"><span>    // console.log(&#39;[sw2]fetch but do nothing&#39;)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    event.respondWith(</span></span>
<span class="line"><span>        // caches.match() will look for a cache entry in all of the caches available to the service worker.</span></span>
<span class="line"><span>        // It&#39;s an alternative to first opening a specific named cache and then matching on that.</span></span>
<span class="line"><span>        caches.match(event.request).then(function(response) {</span></span>
<span class="line"><span>            if (response) {</span></span>
<span class="line"><span>                console.log(&#39;Found response in cache:&#39;, response);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>                return response;</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>            console.log(&#39;No response found in cache. About to fetch from network...&#39;);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>            // event.request will always have the proper mode set (&#39;cors, &#39;no-cors&#39;, etc.) so we don&#39;t</span></span>
<span class="line"><span>            // have to hardcode &#39;no-cors&#39; like we do when fetch()ing in the install handler.</span></span>
<span class="line"><span>            return fetch(event.request).then(function(response) {</span></span>
<span class="line"><span>                console.log(&#39;Response from network is:&#39;, response);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>                return response;</span></span>
<span class="line"><span>            }).catch(function(error) {</span></span>
<span class="line"><span>                // This catch() will handle exceptions thrown from the fetch() operation.</span></span>
<span class="line"><span>                // Note that a HTTP error response (e.g. 404) will NOT trigger an exception.</span></span>
<span class="line"><span>                // It will return a normal response object that has the appropriate error code set.</span></span>
<span class="line"><span>                console.error(&#39;Fetching failed:&#39;, error);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>                throw error;</span></span>
<span class="line"><span>            });</span></span>
<span class="line"><span>        })</span></span>
<span class="line"><span>    );</span></span>
<span class="line"><span>});</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br></div></div><p>有两点要注意的：</p><p>我们如果这样代理了，哪怕没有 cache 命中，实际上也会在控制台写from serviceWorker，而那些真正由serviceWorker发出的请求也会显示，有一个齿轮图标，如下图：</p><p><img src="https://www.10000h.top/images/sw_1.png" alt="" loading="lazy"></p><p>第二点就是我们如果在 fetch 的 listener 里面 do nothing， 也不会导致这个请求直接假死掉的。</p><p>另外，通过上面的代码我们发现，实际上由于现在我们习惯给我们的文件资源加上 hash，所以我们基本上不可能手动输入需要缓存的文件列表，现在大多数情况下，我们都是借助 webpack 插件，完成这部分工作。</p><h3 id="serviceworker-和-页面之间的通信" tabindex="-1">serviceWorker 和 页面之间的通信 <a class="header-anchor" href="#serviceworker-和-页面之间的通信" aria-label="Permalink to &quot;serviceWorker 和 页面之间的通信&quot;">​</a></h3><p>serviceWorker向页面发消息：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>sw.js:</span></span>
<span class="line"><span></span></span>
<span class="line"><span>self.clients.matchAll().then(clients =&gt; {</span></span>
<span class="line"><span>    clients.forEach(client =&gt; {</span></span>
<span class="line"><span>        console.log(&#39;%c [sw message]&#39;, &#39;color:#00aa00&#39;, client)</span></span>
<span class="line"><span>        client.postMessage(&quot;This message is from serviceWorker&quot;)</span></span>
<span class="line"><span>    })</span></span>
<span class="line"><span>})</span></span>
<span class="line"><span></span></span>
<span class="line"><span>主页面:</span></span>
<span class="line"><span></span></span>
<span class="line"><span>navigator.serviceWorker.addEventListener(&#39;message&#39;, function (event) {</span></span>
<span class="line"><span>    console.log(&#39;[Main] receive from serviceWorker:&#39;, event.data, event)</span></span>
<span class="line"><span>});</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>当然，这里面是有坑的：</p><ul><li>主界面的事件监听需要等serviceWorker注册完毕后，所以一般<code>navigator.serviceWorker.register</code>的回调到来之后再进行注册(或者延迟足够的时间)。</li><li>如果在主界面事件监听还没有注册成功的时候 serviceWorker 发送消息，自然是收不到的。如果我们把 serviceWorker 直接写在 install 的回调中，也是不能被正常收到的。</li></ul><p>从页面向 serviceWorker 发送消息：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>主页面:</span></span>
<span class="line"><span></span></span>
<span class="line"><span>navigator.serviceWorker.controller &amp;&amp; navigator.serviceWorker.controller.postMessage(&#39;hello serviceWorker&#39;);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>sw.js:</span></span>
<span class="line"><span>self.addEventListener(&#39;message&#39;, function (event) {</span></span>
<span class="line"><span>    console.log(&quot;[sw from main]&quot;,event.data); // 输出：&#39;sw.updatedone&#39;</span></span>
<span class="line"><span>});</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>同样的，这也要求主界面的代码需要等到serviceWorker注册完毕后触发，另外还有一点值得注意， serviceWorker 的事件绑定代码要求主界面的serviceWorker已经注册完毕后才可以。</p><p>也就是说，如果当前页面没有该serviceWorker 第一次注册是不会收到主界面接收到的消息的。</p><p>记住，只有当前已经在 active 的 serviceWorker， 才能和主页面收发消息等。</p><p><strong>以上就是和 serviceWorker 有关的一些内容，在下一篇文章中，我会对PWA 添加至主屏幕等功能进行总结</strong></p>`,53),l=[r];function i(c,t,o,b,u,d){return a(),n("div",null,l)}const h=s(p,[["render",i]]);export{m as __pageData,h as default};
