import{_ as s,c as a,o as e,a6 as n}from"./chunks/framework.d-Ywx6yJ.js";const h=JSON.parse('{"title":"入门WebAssembly以及使用其进行图像卷积处理","description":"","frontmatter":{"title":"入门WebAssembly以及使用其进行图像卷积处理","date":"2019-02-16T19:15:51.000Z"},"headers":[],"relativePath":"doc/tech/入门WebAssembly以及使用其进行图像卷积处理.md","filePath":"doc/tech/入门WebAssembly以及使用其进行图像卷积处理.md"}'),p={name:"doc/tech/入门WebAssembly以及使用其进行图像卷积处理.md"},l=n(`<blockquote><p>WebAssembly 出现有很长时间了，但是由于日常工作并无直接接触，因此一直疏于尝试，最近终于利用一些业余时间简单入门了一下，因此在此总结。</p></blockquote><h3 id="简介" tabindex="-1">简介 <a class="header-anchor" href="#简介" aria-label="Permalink to &quot;简介&quot;">​</a></h3><p>首先我们需要知道 WebAssembly 是一个什么东西，其实际是一个字节码编码方式，比较接近机器码（但是又无法直接执行），这样可以方便地做到跨平台同时省去像 JavaScript 等语言的解释时间，所以是有一定优势的，使用起来其实也比较灵活，凡是可以转化成字节码的，都是可以使用 WebAssembly。</p><p>以下仅列举部分可以支持 WebAssembly 转化的语言：</p><ul><li><a href="https://github.com/AssemblyScript/assemblyscript" target="_blank" rel="noreferrer">AssemblyScript</a>: 语法和 TypeScript 一致(事实上，其是 Typescript 的一个子集)，对前端来说学习成本低，为前端编写 WebAssembly 最佳选择；</li><li>c\\c++: 官方推荐的方式，详细使用见<a href="http://webassembly.org.cn/getting-started/developers-guide/" target="_blank" rel="noreferrer">文档</a>;</li><li><a href="https://www.rust-lang.org/" target="_blank" rel="noreferrer">Rust</a>: 语法复杂、学习成本高，对前端来说可能会不适应。详细使用见<a href="https://github.com/rust-lang-nursery/rust-wasm" target="_blank" rel="noreferrer">文档</a>;</li><li><a href="http://kotlinlang.org/" target="_blank" rel="noreferrer">Kotlin</a>: 语法和 Java、JS 相似，语言学习成本低，详细使用见<a href="https://kotlinlang.org/docs/reference/native-overview.html" target="_blank" rel="noreferrer">文档</a>;</li><li><a href="https://golang.org/" target="_blank" rel="noreferrer">Golang</a>: 语法简单学习成本低。但对 WebAssembly 的支持还处于未正式发布阶段，详细使用见<a href="https://blog.gopheracademy.com/advent-2017/go-wasm/" target="_blank" rel="noreferrer">文档</a>。</li></ul><p>尝试使用 WebAssembly 官方推荐的方式，我们首先可以在<a href="http://webassembly.org.cn/getting-started/developers-guide/" target="_blank" rel="noreferrer">这里</a>来下载。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>export https_proxy=&quot;http://127.0.0.1:8899&quot;</span></span>
<span class="line"><span>export http_proxy=&quot;http://127.0.0.1:8899&quot;</span></span>
<span class="line"><span>// 文件代理：</span></span>
<span class="line"><span>https://s3.amazonaws.com/mozilla-games/emscripten/packages/node-v8.9.1-darwin-x64.tar.gz file:///Users/niexiaotao/node-v8.9.1-darwin-x64.tar.gz</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="初体验" tabindex="-1">初体验 <a class="header-anchor" href="#初体验" aria-label="Permalink to &quot;初体验&quot;">​</a></h2><p>这里考虑到前端同学的上手难度，我们先使用 AssemblyScript 写一个极小的例子，一个斐波那契函数：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>export function f(x: i32): i32 {</span></span>
<span class="line"><span>    if (x === 1 || x === 2) {</span></span>
<span class="line"><span>        return 1;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    return f(x - 1) + f(x - 2)</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>通过类似 <code>asc f.ts -o f.wasm</code> 这样的命令编译成 f.wasm 之后，我们可以分别在 Node 环境和浏览器环境来执行：</p><p>Node：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>const fs = require(&quot;fs&quot;);</span></span>
<span class="line"><span>const wasm = new WebAssembly.Module(</span></span>
<span class="line"><span>    fs.readFileSync(__dirname + &quot;/f.wasm&quot;), {}</span></span>
<span class="line"><span>);</span></span>
<span class="line"><span>const myModule = new WebAssembly.Instance(wasm).exports;</span></span>
<span class="line"><span>console.log(myModule.f(12));</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>浏览器：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>fetch(&#39;f.wasm&#39;) // 网络加载 f.wasm 文件</span></span>
<span class="line"><span>        .then(res =&gt; res.arrayBuffer()) // 转成 ArrayBuffer</span></span>
<span class="line"><span>        .then( buffer =&gt;</span></span>
<span class="line"><span>            WebAssembly.compile(buffer)</span></span>
<span class="line"><span>        )</span></span>
<span class="line"><span>        .then(module =&gt; { // 调用模块实例上的 f 函数计算</span></span>
<span class="line"><span>            const instance = new WebAssembly.Instance(module);</span></span>
<span class="line"><span>            const { f } = instance.exports;</span></span>
<span class="line"><span>            console.log(&#39;instance:&#39;, instance.exports);</span></span>
<span class="line"><span>            console.log(&#39;f(20):&#39;, f(20));</span></span>
<span class="line"><span>        });</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>于是，我们完成了 WebAssembly 的初体验。</p><p>当然，这个例子太简单了。</p><h2 id="使用-webassembly-进行图像卷积处理" tabindex="-1">使用 WebAssembly 进行图像卷积处理 <a class="header-anchor" href="#使用-webassembly-进行图像卷积处理" aria-label="Permalink to &quot;使用 WebAssembly 进行图像卷积处理&quot;">​</a></h2><p>实际上，WebAssembly 的目的在于解决一些复杂的计算问题，优化 JavaScript 的执行效率。所以我们可以使用 WebAssembly 来处理一些图像或者矩阵的计算问题。</p><p>接下来，我们通过 WebAssembly 来处理一些图像的卷积问题，用于图像的风格变换，我们最终的例子可以在<a href="http://assembly.niexiaotao.com/" target="_blank" rel="noreferrer">这里</a>体验。</p><p>每次进行卷积处理，我们的整个流程是这样的：</p><ul><li>将原图像使用 canvas 绘制到屏幕上。</li><li>使用 <code>getImageData</code> 获取图像像素内容，并转化成类型数组。</li><li>将上述类型数组通过共享内存的方式传递给 WebAssembly 部分。</li><li>WebAssembly 部分接收到数据，进行计算，并且通过共享内存的方式返回。</li><li>将最终结果通过 canvas 画布更新。</li></ul><p>上述各个步骤中，绘制的部分集中在 JavaScript 端，而计算的部分集中在 WebAssembly，这两部分相互比较独立，可以分开编写，而双端数据通信是一个比较值得注意的地方，事实上，我们可以通过 ArrayBuffer 来实现双端通信，简单的说，JavaScript 端和 WebAssembly 可以共享一部分内存，并且都拥有读写能力，当一端写入新数据之后，另一段也可以读到，这样我们就可以进行通信了。</p><p>关于数据通信的问题，这里还有一个比较直白的<a href="https://segmentfault.com/a/1190000010434237" target="_blank" rel="noreferrer">科普文章</a>，可以参考。</p><p>在这里没有必要对整个项目代码进行展示，因此可以参考（<a href="https://github.com/aircloud/assemConvolution" target="_blank" rel="noreferrer">代码地址</a>），我们这里仅仅对部分关键代码进行说明。</p><h3 id="共享内存" tabindex="-1">共享内存 <a class="header-anchor" href="#共享内存" aria-label="Permalink to &quot;共享内存&quot;">​</a></h3><p>首先，我们需要声明一块共享内存，这其实可以使用 WebAssembly 的 API 来完成：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>let memory = new WebAssembly.Memory({ initial: ((memSize + 0xffff) &amp; ~0xffff) &gt;&gt;&gt; 16 });</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>这里经过这样的比较复杂的计算是因为 initial 传入的是以 page 为单位，详细可以参考<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/Memory" target="_blank" rel="noreferrer">这里</a>，实际上 memSize 即我们共享内存的字节数。</p><p>然后这里涉及到 memSize 的计算，我们主要需要存储三块数据：卷积前的数据、卷积后的数据（由于卷积算法的特殊性以及为了避免更多麻烦，这里我们不进行数据共用），还有卷积核作为参数需要传递。</p><p>这里我们共享内存所传递的数据按照如下的规则进行设计：</p><p><img src="http://niexiaotao.cn/img/ker1.jpg" alt="" loading="lazy"></p><p>传递给 WebAssembly 端的方式并不复杂，直接在 <code>WebAssembly.instantiate</code> 中声明即可。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>fetch(wasmPath)</span></span>
<span class="line"><span>     .then(response =&gt; response.arrayBuffer())</span></span>
<span class="line"><span>     .then(buffer =&gt; WebAssembly.instantiate(buffer, {</span></span>
<span class="line"><span>         env: {</span></span>
<span class="line"><span>             memory,</span></span>
<span class="line"><span>             abort: function() {}</span></span>
<span class="line"><span>         },</span></span>
<span class="line"><span>         Math</span></span>
<span class="line"><span>     })).then(module =&gt; {})</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>然后我们在 AssemblyScript 中就可以进行读写了：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>//写：</span></span>
<span class="line"><span>store&lt;u32&gt;(position, v) // position 为位置</span></span>
<span class="line"><span></span></span>
<span class="line"><span>//读：</span></span>
<span class="line"><span>load&lt;u32&gt;(position) // position 为位置</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>而在 JavaScript 端，我们也可以通过 <code>memory.buffer</code> 拿到数据，并且转化成类型数组：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>let mem = new Uint32Array(memory.buffer)</span></span>
<span class="line"><span>//通过 mem.set(data) 可以在 JavaScript 端进行写入操作</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>这样，我们在 JavaScript 端和 AssemblyScript 端的读写都明晰了。</p><p>这里需要注意的是，<strong>JS端采用的是大端数据格式，而 AssemblyScript 中采用的是小端，因此其颜色数据格式为 AGBR</strong></p><h3 id="卷积计算" tabindex="-1">卷积计算 <a class="header-anchor" href="#卷积计算" aria-label="Permalink to &quot;卷积计算&quot;">​</a></h3><p>我们所采用的卷积计算本身算法比较简单，并且不是本次的重点，但是这里需要注意的是：</p><ul><li>我们无法直接在 AssemblyScript 中声明数组并使用，因此除了 Kernel 通过共享内存的方式传递过来以外，我们应当尽量避免声明数组使用（虽然也有使用非共享内存数组的相关操作，但是使用起来比较繁琐）</li><li>卷积应当对 R、G、B 三层单独进行，我这里 A 层不参与卷积。</li></ul><p>以上都在代码中有所体现，参考相关代码便可明了。</p><p>卷积完成后，我们通过共享内存的方法写入类型数组，然后在 JavaScript 端合成数据，调用 <code>putImageData</code> 上屏即可。</p><h3 id="其他" tabindex="-1">其他 <a class="header-anchor" href="#其他" aria-label="Permalink to &quot;其他&quot;">​</a></h3><p>当然，本次图像卷积程序仅仅是对 Webassembly 和 AssemblyScript 的初步尝试，笔者也在学习阶段，如果上述说法有问题或者你想和我交流，也欢迎留言或者提相关 issue。</p>`,47),r=[l];function i(t,c,b,o,m,u){return e(),a("div",null,r)}const g=s(p,[["render",i]]);export{h as __pageData,g as default};
